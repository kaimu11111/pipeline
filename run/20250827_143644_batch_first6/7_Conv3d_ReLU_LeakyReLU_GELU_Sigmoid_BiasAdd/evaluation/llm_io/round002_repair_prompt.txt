You are a senior CUDA-extension developer.
Your job is to **FIX** the compilation or runtime errors in the Python script
shown below.

OUTPUT RULES (STRICT) ────────────────────────────────────────────────
1. Inside the block, follow **exactly** this order:
   1. Imports – `torch`, `torch.nn`, `load_inline`.
   2. `source` – triple‑quoted CUDA string(s) (kernel + host wrapper).
   3. `cpp_src` – prototypes for *all* kernels you expose.
   4. **One** `load_inline` call per kernel group.
   5. `class ModelNew(nn.Module)` – mirrors original inputs/outputs but calls
      your CUDA kernels.
2. **Do NOT include** testing code, `if __name__ == "__main__"`, or extra prose.

────────────────────────────────────────
ERROR LOG
────────────────────────────────────────
Traceback (most recent call last):
  File "/home/wan00559/pipleline/utils/compile_and_run.py", line 536, in compare_and_bench
    diff = (test_out - ref_out).abs()
            ~~~~~~~~~^~~~~~~~~
RuntimeError: The size of tensor a (32) must match the size of tensor b (30) at non-singleton dimension 4

────────────────────────────────────────
OLD CODE (read-only)
────────────────────────────────────────
import torch
import torch.nn as nn
from torch.utils.cpp_extension import load_inline

# ---------------------------------------------------------------------
# CUDA source – kernel + host wrapper (NO pybind11 module here)
# ---------------------------------------------------------------------
source = r"""
#include <torch/extension.h>
#include <cuda.h>
#include <cuda_runtime.h>
#include <math.h>

__global__ void fused_act_bias_kernel(const float* __restrict__ inp,
                                      const float* __restrict__ bias,
                                      float* __restrict__ out,
                                      int channels,
                                      int inner_size,
                                      int total) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx >= total) return;

    float v = inp[idx];

    // ReLU
    v = v > 0.0f ? v : 0.0f;

    // LeakyReLU (negative_slope = 0.01)
    v = v > 0.0f ? v : 0.01f * v;

    // GELU (tanh approximation)
    const float k0 = 0.7978845608028654f;   // sqrt(2/pi)
    const float k1 = 0.044715f;
    float inner = k0 * (v + k1 * v * v * v);
    float cdf   = 0.5f * (1.0f + tanhf(inner));
    v = v * cdf;

    // Sigmoid
    v = 1.0f / (1.0f + expf(-v));

    // Add bias (broadcast over spatial dims)
    int c = (idx / inner_size) % channels;
    v += bias[c];

    out[idx] = v;
}

torch::Tensor fused_act_bias_cuda(torch::Tensor x, torch::Tensor bias) {
    TORCH_CHECK(x.is_cuda(),  "x must be a CUDA tensor");
    TORCH_CHECK(bias.is_cuda(), "bias must be a CUDA tensor");
    TORCH_CHECK(x.scalar_type() == torch::kFloat32,  "x must be float32");
    TORCH_CHECK(bias.scalar_type() == torch::kFloat32, "bias must be float32");

    auto x_contig    = x.contiguous();
    auto bias_contig = bias.contiguous();
    auto out         = torch::empty_like(x_contig);

    const int channels   = x_contig.size(1);
    const int depth      = x_contig.size(2);
    const int height     = x_contig.size(3);
    const int width      = x_contig.size(4);
    const int inner_size = depth * height * width;
    const int total      = x_contig.numel();

    const int block_size = 256;
    const int grid_size  = (total + block_size - 1) / block_size;

    fused_act_bias_kernel<<<grid_size, block_size>>>(
        x_contig.data_ptr<float>(),
        bias_contig.data_ptr<float>(),
        out.data_ptr<float>(),
        channels,
        inner_size,
        total
    );

    return out;
}
"""

# ---------------------------------------------------------------------
# C++ prototypes that will be seen by the auto-generated pybind wrapper
# ---------------------------------------------------------------------
cpp_src = r"""
torch::Tensor fused_act_bias_cuda(torch::Tensor x, torch::Tensor bias);
"""

# ---------------------------------------------------------------------
# Build & load the extension (only one load_inline call)
# ---------------------------------------------------------------------
fused_ops = load_inline(
    name="fused_act_bias",
    cpp_sources=cpp_src,
    cuda_sources=source,
    functions=["fused_act_bias_cuda"],
    verbose=False,
)

# ---------------------------------------------------------------------
# PyTorch module that calls the fused CUDA kernel
# ---------------------------------------------------------------------
class ModelNew(nn.Module):
    def __init__(self, in_channels, out_channels, kernel_size, bias_shape):
        super().__init__()
        self.conv = nn.Conv3d(in_channels, out_channels, kernel_size, padding=kernel_size // 2)
        self.bias = nn.Parameter(torch.randn(bias_shape))
        self._fused = fused_ops

    def forward(self, x):
        x = self.conv(x)
        bias_flat = self.bias.view(-1).contiguous().to(x.device)
        x = self._fused.fused_act_bias_cuda(x, bias_flat)
        return x

────────────────────────────────────────
Main Critical Problem
────────────────────────────────────────
critical_issue: Conv3d uses padding=1 instead of 0
why_it_matters: Extra padding preserves spatial size; reference shrinks, giving 32 vs 30 dimensions and completely mismatched outputs.
minimal_fix_hint: Set Conv3d padding to 0

```python
# <your corrected code>
```
# ==========================================================
