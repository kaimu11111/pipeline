You are given:

ERROR_LOG:
/home/wan00559/miniconda3/envs/maxk/lib/python3.11/site-packages/torch/utils/cpp_extension.py:2356: UserWarning: TORCH_CUDA_ARCH_LIST is not set, all archs for visible cards are included for compilation. 
If this is not desired, please set os.environ['TORCH_CUDA_ARCH_LIST'].
  warnings.warn(
Error building extension 'hardtanh_ext': [1/3] c++ -MMD -MF main.o.d -DTORCH_EXTENSION_NAME=hardtanh_ext -DTORCH_API_INCLUDE_EXTENSION_H -DPYBIND11_COMPILER_TYPE=\"_gcc\" -DPYBIND11_STDLIB=\"_libstdcpp\" -DPYBIND11_BUILD_ABI=\"_cxxabi1016\" -isystem /home/wan00559/miniconda3/envs/maxk/lib/python3.11/site-packages/torch/include -isystem /home/wan00559/miniconda3/envs/maxk/lib/python3.11/site-packages/torch/include/torch/csrc/api/include -isystem /home/wan00559/miniconda3/envs/maxk/include/python3.11 -D_GLIBCXX_USE_CXX11_ABI=1 -fPIC -std=c++17 -c /home/wan00559/.cache/torch_extensions/py311_cu126/hardtanh_ext/main.cpp -o main.o 
[2/3] /usr/bin/nvcc --generate-dependencies-with-compile --dependency-output cuda.cuda.o.d -DTORCH_EXTENSION_NAME=hardtanh_ext -DTORCH_API_INCLUDE_EXTENSION_H -DPYBIND11_COMPILER_TYPE=\"_gcc\" -DPYBIND11_STDLIB=\"_libstdcpp\" -DPYBIND11_BUILD_ABI=\"_cxxabi1016\" -isystem /home/wan00559/miniconda3/envs/maxk/lib/python3.11/site-packages/torch/include -isystem /home/wan00559/miniconda3/envs/maxk/lib/python3.11/site-packages/torch/include/torch/csrc/api/include -isystem /home/wan00559/miniconda3/envs/maxk/include/python3.11 -D_GLIBCXX_USE_CXX11_ABI=1 -D__CUDA_NO_HALF_OPERATORS__ -D__CUDA_NO_HALF_CONVERSIONS__ -D__CUDA_NO_BFLOAT16_CONVERSIONS__ -D__CUDA_NO_HALF2_OPERATORS__ --expt-relaxed-constexpr -gencode=arch=compute_75,code=compute_75 -gencode=arch=compute_75,code=sm_75 --compiler-options '-fPIC' -std=c++17 -c /home/wan00559/.cache/torch_extensions/py311_cu126/hardtanh_ext/cuda.cu -o cuda.cuda.o 
[3/3] c++ main.o cuda.cuda.o -shared -L/home/wan00559/miniconda3/envs/maxk/lib/python3.11/site-packages/torch/lib -lc10 -lc10_cuda -ltorch_cpu -ltorch_cuda -ltorch -ltorch_python -L/usr/lib64 -lcudart -o hardtanh_ext.so
FAILED: hardtanh_ext.so 
c++ main.o cuda.cuda.o -shared -L/home/wan00559/miniconda3/envs/maxk/lib/python3.11/site-packages/torch/lib -lc10 -lc10_cuda -ltorch_cpu -ltorch_cuda -ltorch -ltorch_python -L/usr/lib64 -lcudart -o hardtanh_ext.so
/usr/bin/ld: cuda.cuda.o: in function `PyInit_hardtanh_ext':
tmpxft_003ce1c3_00000000-6_cuda.cudafe1.cpp:(.text+0x9fa): multiple definition of `PyInit_hardtanh_ext'; main.o:main.cpp:(.text+0x257): first defined here
collect2: error: ld returned 1 exit status
ninja: build stopped: subcommand failed.

PyTorch reference (ground truth):

import torch
import torch.nn as nn

class Model(nn.Module):
    """
    Simple model that performs a GEMM, applies Group Normalization, and then HardTanh.
    """
    def __init__(self, in_features, out_features, num_groups, hardtanh_min, hardtanh_max):
        super(Model, self).__init__()
        self.gemm = nn.Linear(in_features, out_features)
        self.group_norm = nn.GroupNorm(num_groups, out_features)
        self.hardtanh = nn.Hardtanh(min_val=hardtanh_min, max_val=hardtanh_max)

    def forward(self, x):
        """
        Args:
            x (torch.Tensor): Input tensor of shape (batch_size, in_features).
        Returns:
            torch.Tensor: Output tensor of shape (batch_size, out_features).
        """
        x = self.gemm(x)
        x = self.group_norm(x)
        x = self.hardtanh(x)
        return x

batch_size = 512
in_features = 4096
out_features = 4096
num_groups = 8
hardtanh_min = -2.0
hardtanh_max = 2.0

def get_inputs():
    return [torch.rand(batch_size, in_features)]

def get_init_inputs():
    return [in_features, out_features, num_groups, hardtanh_min, hardtanh_max]

CUDA candidate (to audit):

import torch
import torch.nn as nn
from torch.utils.cpp_extension import load_inline


# ---------------------------------------------------------------------------
# Inline CUDA implementation of HardTanh (clamp) with min / max parameters
# ---------------------------------------------------------------------------
cuda_source = r"""
#include <torch/extension.h>
#include <cuda.h>
#include <cuda_runtime.h>

template <typename scalar_t>
__global__ void hardtanh_kernel(const scalar_t* __restrict__ input,
                                scalar_t* __restrict__ output,
                                scalar_t min_val,
                                scalar_t max_val,
                                int64_t numel) {
    const int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx >= numel) return;

    scalar_t val = input[idx];
    if (val < min_val)      val = min_val;
    else if (val > max_val) val = max_val;
    output[idx] = val;
}

torch::Tensor hardtanh_cuda(torch::Tensor input, double min_val, double max_val) {
    TORCH_CHECK(input.is_cuda(), "Input tensor must reside on CUDA device");

    auto output = torch::empty_like(input);
    const int64_t numel   = input.numel();
    const int     threads = 256;
    const int     blocks  = (numel + threads - 1) / threads;

    AT_DISPATCH_FLOATING_TYPES_AND_HALF(input.scalar_type(), "hardtanh_cuda", ([&] {
        hardtanh_kernel<scalar_t><<<blocks, threads>>>(
            input.data_ptr<scalar_t>(),
            output.data_ptr<scalar_t>(),
            static_cast<scalar_t>(min_val),
            static_cast<scalar_t>(max_val),
            numel);
    }));

    return output;
}

PYBIND11_MODULE(TORCH_EXTENSION_NAME, m) {
    m.def("hardtanh_cuda", &hardtanh_cuda, "HardTanh CUDA kernel (clamp)");
}
"""

cpp_decl = "torch::Tensor hardtanh_cuda(torch::Tensor input, double min_val, double max_val);"

# Build/load the kernel
hardtanh_ext = load_inline(
    name="hardtanh_ext",
    cpp_sources=cpp_decl,
    cuda_sources=cuda_source,
    functions=["hardtanh_cuda"],
    verbose=False,
)


# ---------------------------------------------------------------------------
# Optimized model that swaps out PyTorch's HardTanh with the custom CUDA op
# ---------------------------------------------------------------------------
class ModelNew(nn.Module):
    """
    Optimized model:
        Linear -> GroupNorm -> custom CUDA HardTanh
    """
    def __init__(self,
                 in_features: int,
                 out_features: int,
                 num_groups: int,
                 hardtanh_min: float,
                 hardtanh_max: float):
        super().__init__()
        self.gemm = nn.Linear(in_features, out_features)
        self.group_norm = nn.GroupNorm(num_groups, out_features)
        self.hardtanh_min = hardtanh_min
        self.hardtanh_max = hardtanh_max
        self._cuda_op = hardtanh_ext.hardtanh_cuda

    def forward(self, x: torch.Tensor) -> torch.Tensor:
        x = self.gemm(x)
        x = self.group_norm(x)
        # Use the custom CUDA op if the tensor is on GPU, else fall back to torch
        if x.is_cuda:
            x = self._cuda_op(x, self.hardtanh_min, self.hardtanh_max)
        else:
            x = torch.clamp(x, self.hardtanh_min, self.hardtanh_max)
        return x


Follow the Rules and produce the JSON exactly in the specified format.