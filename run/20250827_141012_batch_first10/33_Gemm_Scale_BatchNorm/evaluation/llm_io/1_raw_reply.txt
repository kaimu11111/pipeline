```python
import torch
import torch.nn as nn
from torch.utils.cpp_extension import load_inline

# ------------------------------------------------------------------
# 1. CUDA source (kernel + host wrapper, NO module definition)
# ------------------------------------------------------------------
source = r"""
#include <torch/extension.h>
#include <cuda_runtime.h>

template <typename scalar_t>
__global__ void scale_mul_kernel(const scalar_t* __restrict__ x,
                                 const scalar_t* __restrict__ scale,
                                 scalar_t* __restrict__ out,
                                 int rows,
                                 int cols) {
    int idx   = blockIdx.x * blockDim.x + threadIdx.x;
    int total = rows * cols;
    if (idx < total) {
        int col  = idx % cols;
        out[idx] = x[idx] * scale[col];
    }
}

torch::Tensor scale_mul_cuda(torch::Tensor x, torch::Tensor scale) {
    x     = x.contiguous();
    scale = scale.contiguous();

    const int rows  = x.size(0);
    const int cols  = x.size(1);
    const int total = rows * cols;

    auto out = torch::empty_like(x);

    const int threads = 256;
    const int blocks  = (total + threads - 1) / threads;

    AT_DISPATCH_FLOATING_TYPES(x.scalar_type(), "scale_mul_cuda", ([&] {
        scale_mul_kernel<scalar_t><<<blocks, threads>>>(
            x.data_ptr<scalar_t>(),
            scale.data_ptr<scalar_t>(),
            out.data_ptr<scalar_t>(),
            rows,
            cols);
    }));

    return out;
}
"""

# ------------------------------------------------------------------
# 2. C++ declarations for all exposed kernels
# ------------------------------------------------------------------
cpp_src = r"""
torch::Tensor scale_mul_cuda(torch::Tensor x, torch::Tensor scale);
"""

# ------------------------------------------------------------------
# 3. Build & load the extension
# ------------------------------------------------------------------
scale_mul = load_inline(
    name="scale_mul",
    cpp_sources=cpp_src,
    cuda_sources=source,
    functions=["scale_mul_cuda"],
    verbose=False,
)

# ------------------------------------------------------------------
# 4. Optimised model using the custom kernel
# ------------------------------------------------------------------
class ModelNew(nn.Module):
    def __init__(self, in_features, out_features, scale_shape,
                 eps: float = 1e-5, momentum: float = 0.1):
        super().__init__()
        self.gemm  = nn.Linear(in_features, out_features)
        self.scale = nn.Parameter(torch.randn(scale_shape, device="cuda"))
        self.bn    = nn.BatchNorm1d(out_features, eps=eps, momentum=momentum)

    def forward(self, x: torch.Tensor) -> torch.Tensor:
        x = self.gemm(x)
        x = scale_mul.scale_mul_cuda(x, self.scale)
        x = self.bn(x)
        return x
```