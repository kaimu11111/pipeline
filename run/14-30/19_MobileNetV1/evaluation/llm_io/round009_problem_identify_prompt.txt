You are given:

ERROR_LOG:
Traceback (most recent call last):
  File "/home/wan00559/pipleline/utils/compile_and_run.py", line 524, in compare_and_bench
    ref_out,  _ = _run_once(ref_model,  inp, dev)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/wan00559/pipleline/utils/compile_and_run.py", line 127, in _run_once
    out = model(*inp)
          ^^^^^^^^^^^
  File "/home/wan00559/miniconda3/envs/maxk/lib/python3.11/site-packages/torch/nn/modules/module.py", line 1751, in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/wan00559/miniconda3/envs/maxk/lib/python3.11/site-packages/torch/nn/modules/module.py", line 1762, in _call_impl
    return forward_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/wan00559/pipleline/KernelBench/temp/19_MobileNetV1.py", line 58, in forward
    x = self.model(x)
        ^^^^^^^^^^^^^
  File "/home/wan00559/miniconda3/envs/maxk/lib/python3.11/site-packages/torch/nn/modules/module.py", line 1751, in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/wan00559/miniconda3/envs/maxk/lib/python3.11/site-packages/torch/nn/modules/module.py", line 1762, in _call_impl
    return forward_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/wan00559/miniconda3/envs/maxk/lib/python3.11/site-packages/torch/nn/modules/container.py", line 240, in forward
    input = module(input)
            ^^^^^^^^^^^^^
  File "/home/wan00559/miniconda3/envs/maxk/lib/python3.11/site-packages/torch/nn/modules/module.py", line 1751, in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/wan00559/miniconda3/envs/maxk/lib/python3.11/site-packages/torch/nn/modules/module.py", line 1762, in _call_impl
    return forward_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/wan00559/miniconda3/envs/maxk/lib/python3.11/site-packages/torch/nn/modules/pooling.py", line 756, in forward
    return F.avg_pool2d(
           ^^^^^^^^^^^^^
RuntimeError: Given input size: (1024x4x4). Calculated output size: (1024x0x0). Output size is too small

PyTorch reference (ground truth):

import torch
import torch.nn as nn
import torch.nn.functional as F

class Model(nn.Module):
    def __init__(self, num_classes=1000, input_channels=3, alpha=1.0):
        """
        MobileNetV1 architecture implementation.

        :param num_classes: The number of output classes (default: 1000)
        :param input_channels: The number of input channels (default: 3 for RGB images)
        :param alpha: Width multiplier (default: 1.0)
        """
        super(Model, self).__init__()
        
        def conv_bn(inp, oup, stride):
            return nn.Sequential(
                nn.Conv2d(inp, oup, 3, stride, 1, bias=False),
                nn.BatchNorm2d(oup),
                nn.ReLU(inplace=True)
            )
        
        def conv_dw(inp, oup, stride):
            return nn.Sequential(
                nn.Conv2d(inp, inp, 3, stride, 1, groups=inp, bias=False),
                nn.BatchNorm2d(inp),
                nn.ReLU(inplace=True),
                
                nn.Conv2d(inp, oup, 1, 1, 0, bias=False),
                nn.BatchNorm2d(oup),
                nn.ReLU(inplace=True),
            )
        
        self.model = nn.Sequential(
            conv_bn(input_channels, int(32 * alpha), 2),
            conv_dw(int(32 * alpha), int(64 * alpha), 1),
            conv_dw(int(64 * alpha), int(128 * alpha), 2),
            conv_dw(int(128 * alpha), int(128 * alpha), 1),
            conv_dw(int(128 * alpha), int(256 * alpha), 2),
            conv_dw(int(256 * alpha), int(256 * alpha), 1),
            conv_dw(int(256 * alpha), int(512 * alpha), 2),
            conv_dw(int(512 * alpha), int(512 * alpha), 1),
            conv_dw(int(512 * alpha), int(512 * alpha), 1),
            conv_dw(int(512 * alpha), int(512 * alpha), 1),
            conv_dw(int(512 * alpha), int(512 * alpha), 1),
            conv_dw(int(512 * alpha), int(512 * alpha), 1),
            conv_dw(int(512 * alpha), int(1024 * alpha), 2),
            conv_dw(int(1024 * alpha), int(1024 * alpha), 1),
            nn.AvgPool2d(7),
        )
        self.fc = nn.Linear(int(1024 * alpha), num_classes)
    
    def forward(self, x):
        """
        :param x: The input tensor, shape (batch_size, input_channels, height, width)
        :return: The output tensor, shape (batch_size, num_classes)
        """
        x = self.model(x)
        x = x.view(x.size(0), -1)
        x = self.fc(x)
        return x

# Test code
batch_size = 5
input_channels = 3
height = 112
width = 112
num_classes = 100
alpha = 1.0

def get_inputs():
    return [torch.rand(batch_size, input_channels, height, width)]

def get_init_inputs():
    return [num_classes, input_channels, alpha]

CUDA candidate (to audit):

# 1. Imports ──────────────────────────────────────────────────────────
import torch
import torch.nn as nn
from torch.utils.cpp_extension import load_inline

# 2. CUDA sources ─────────────────────────────────────────────────────
source = r"""
#include <torch/extension.h>
#include <ATen/cuda/CUDAContext.h>
#include <cuda.h>
#include <cuda_runtime.h>
#include <cuda_fp16.h>

template <typename scalar_t>
__device__ __forceinline__ bool _isnan(scalar_t x) { return !(x == x); }

template <>
__device__ __forceinline__ bool _isnan<half>(half x) { return __hisnan(x); }

template <typename scalar_t>
__global__ void relu_forward_kernel(const scalar_t* __restrict__ inp,
                                    scalar_t* __restrict__ out,
                                    size_t numel) {
    const int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx < numel) {
        const scalar_t x = inp[idx];
        const bool isnan = _isnan<scalar_t>(x);
        out[idx] = isnan ? x : (x > scalar_t(0) ? x : scalar_t(0));
    }
}

template <typename scalar_t>
__global__ void relu_backward_kernel(const scalar_t* __restrict__ grad_out,
                                     const scalar_t* __restrict__ inp,
                                     scalar_t* __restrict__ grad_in,
                                     size_t numel) {
    const int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx < numel) {
        const scalar_t x = inp[idx];
        const bool isnan = _isnan<scalar_t>(x);
        grad_in[idx] = isnan ? scalar_t(0)
                             : (x > scalar_t(0) ? grad_out[idx] : scalar_t(0));
    }
}

torch::Tensor relu_forward(torch::Tensor input) {
    auto output = torch::empty_like(input);
    const size_t numel = input.numel();
    const int threads = 256;
    const int blocks  = (numel + threads - 1) / threads;

    AT_DISPATCH_FLOATING_TYPES_AND_HALF(
        input.scalar_type(), "relu_forward_cuda", ([&] {
            relu_forward_kernel<scalar_t><<<blocks, threads, 0,
                at::cuda::getCurrentCUDAStream()>>>(
                    input.data_ptr<scalar_t>(),
                    output.data_ptr<scalar_t>(),
                    numel);
        }));
    return output;
}

torch::Tensor relu_backward(torch::Tensor grad_out, torch::Tensor input) {
    auto grad_in = torch::empty_like(input);
    const size_t numel = input.numel();
    const int threads = 256;
    const int blocks  = (numel + threads - 1) / threads;

    AT_DISPATCH_FLOATING_TYPES_AND_HALF(
        input.scalar_type(), "relu_backward_cuda", ([&] {
            relu_backward_kernel<scalar_t><<<blocks, threads, 0,
                at::cuda::getCurrentCUDAStream()>>>(
                    grad_out.data_ptr<scalar_t>(),
                    input.data_ptr<scalar_t>(),
                    grad_in.data_ptr<scalar_t>(),
                    numel);
        }));
    return grad_in;
}

PYBIND11_MODULE(TORCH_EXTENSION_NAME, m) {
    m.def("relu_forward",  &relu_forward,  "Fast ReLU forward (CUDA)");
    m.def("relu_backward", &relu_backward, "Fast ReLU backward (CUDA)");
}
"""

# 3. C++ prototypes ───────────────────────────────────────────────────
cpp_src = r"""
torch::Tensor relu_forward(torch::Tensor input);
torch::Tensor relu_backward(torch::Tensor grad_out, torch::Tensor input);
"""

# 4. Build & load extension ───────────────────────────────────────────
relu_ops = load_inline(
    name="fast_relu",
    cpp_sources=cpp_src,
    cuda_sources=source,
    with_cuda=True,
    verbose=False,
)

# 5. Model definition ─────────────────────────────────────────────────
class ModelNew(nn.Module):
    # ---------- custom autograd for fast ReLU ----------
    class _FastReLU(torch.autograd.Function):
        @staticmethod
        def forward(ctx, x):
            ctx.save_for_backward(x)
            return relu_ops.relu_forward(x.contiguous())

        @staticmethod
        def backward(ctx, grad_out):
            (x,) = ctx.saved_tensors
            return relu_ops.relu_backward(grad_out.contiguous(), x)

    class CUDAReLU(nn.Module):
        def __init__(self, inplace: bool = False):
            super().__init__()
            self.inplace = inplace

        def forward(self, x):
            return ModelNew._FastReLU.apply(x)

    # ---------- MobileNet-V1 skeleton ----------
    def __init__(self, num_classes: int = 1000, input_channels: int = 3,
                 alpha: float = 1.0):
        super().__init__()
        relu = self.CUDAReLU  # alias

        def conv_bn(inp, oup, stride):
            return nn.Sequential(
                nn.Conv2d(inp, oup, 3, stride, 1, bias=False),
                nn.BatchNorm2d(oup),
                relu(inplace=False),
            )

        def conv_dw(inp, oup, stride):
            return nn.Sequential(
                nn.Conv2d(inp, inp, 3, stride, 1, groups=inp, bias=False),
                nn.BatchNorm2d(inp),
                relu(inplace=False),
                nn.Conv2d(inp, oup, 1, 1, 0, bias=False),
                nn.BatchNorm2d(oup),
                relu(inplace=False),
            )

        self.features = nn.Sequential(
            conv_bn(input_channels, int(32 * alpha), 2),
            conv_dw(int(32 * alpha),  int(64  * alpha), 1),
            conv_dw(int(64 * alpha),  int(128 * alpha), 2),
            conv_dw(int(128 * alpha), int(128 * alpha), 1),
            conv_dw(int(128 * alpha), int(256 * alpha), 2),
            conv_dw(int(256 * alpha), int(256 * alpha), 1),
            conv_dw(int(256 * alpha), int(512 * alpha), 2),
            conv_dw(int(512 * alpha), int(512 * alpha), 1),
            conv_dw(int(512 * alpha), int(512 * alpha), 1),
            conv_dw(int(512 * alpha), int(512 * alpha), 1),
            conv_dw(int(512 * alpha), int(512 * alpha), 1),
            conv_dw(int(512 * alpha), int(512 * alpha), 1),
            conv_dw(int(512 * alpha), int(1024 * alpha), 2),
            conv_dw(int(1024 * alpha), int(1024 * alpha), 1),
            nn.AvgPool2d(7),  # fixed-size global average pooling
        )

        self.classifier = nn.Linear(int(1024 * alpha), num_classes)

    def forward(self, x):
        x = self.features(x)
        x = torch.flatten(x, 1)
        return self.classifier(x)


Follow the Rules and produce the JSON exactly in the specified format.